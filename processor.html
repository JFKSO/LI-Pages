<!DOCTYPE html>
<html>
<head>
    <title>LinkedIn Data Processor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .canvas-container { 
            width: 100%; 
            height: 600px;
            background-color: rgb(249, 250, 251);
            border-radius: 0.5rem;
        }
        #processingCanvas {
            width: 100%;
            height: 100%;
        }
        .upload-guide {
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }
        .upload-guide.visible {
            opacity: 1;
            height: auto;
            overflow: visible;
        }
        .step-animation {
            transition: transform 0.3s ease-in-out;
        }
        .step-animation:hover {
            transform: translateX(8px);
        }
    </style>
</head>
<body class="min-h-screen p-8 pt-20 bg-gray-50">
    <!-- Back Icon -->
    <div class="max-w-6xl mx-auto mb-4">
        <button onclick="window.history.back()" class="flex items-center text-blue-600 hover:text-blue-800">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
            </svg>
            Back
        </button>
    </div>

    <!-- Progress Header -->
    <div class="fixed top-0 left-0 right-0 bg-white shadow-md z-50 p-4">
        <div class="max-w-6xl mx-auto">
            <div class="flex justify-between items-center">
                <div class="flex space-x-8">
                    <div class="flex items-center opacity-50">
                        <div class="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center font-bold">1</div>
                        <span class="ml-2 text-sm">Export Contact Map</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white font-bold">2</div>
                        <span class="ml-2 text-sm">Upload & Process</span>
                    </div>
                    <div class="flex items-center opacity-50">
                        <div class="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center font-bold">3</div>
                        <span class="ml-2 text-sm">Discover Insights</span>
                    </div>
                </div>
                <div class="text-sm text-gray-600">Est. Time: 5 mins</div>
            </div>
        </div>
    </div>

    <div class="max-w-6xl mx-auto">
        <div class="bg-white rounded-lg shadow-lg p-8">
            <h2 class="text-2xl font-bold mb-6">Process Your LinkedIn Contacts</h2>

            <!-- Add the new explainer box -->
            <div class="bg-blue-50 border-l-4 border-blue-500 p-6 mb-8 rounded-lg">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-6 w-6 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </div>
                    <div class="ml-4">
                        <h4 class="text-lg font-medium text-blue-800 mb-2">Secure & Private Processing</h4>
                        <p class="text-blue-700">
                            This tool processes your LinkedIn connections directly in your browser - your data never leaves your device. Personal information (names, emails, etc.) is automatically removed before any insights are generated, creating a fully anonymised dataset.
                        </p>
                        <ul class="mt-3 space-y-2 text-blue-700">
                            <li class="flex items-center">
                                <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                One-way encrypted tokens ensure data privacy
                            </li>
                            <li class="flex items-center">
                                <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                Preview processing steps before completion
                            </li>
                            <li class="flex items-center">
                                <svg class="h-4 w-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                Secure SharePoint storage for processed files
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="space-y-6 mb-8">
                <div class="space-y-2">
                    <label for="uploaderName" class="block font-semibold">Your Name</label>
                    <input type="text" id="uploaderName" required class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <span id="nameWarning" class="text-red-500 text-sm" style="display: none;">Please enter your name</span>
                </div>

                <div class="space-y-2">
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" id="enableTracking" class="w-4 h-4 text-blue-600" checked>
                        <span class="font-semibold">Maintain preferences across roles</span>
                    </label>
                    <div class="text-sm text-gray-600">Enables tracking of role changes by creating a secure identifier for managing contact preferences across roles. This helps maintain consistent engagement preferences when a new role is identifed at a company, while providing aggregate insights to inform relationship-building strategy. Without this, each role is treated as a separate contact.</div>
                </div>

                <div class="space-y-4">
                    <input type="file" id="fileInput" accept=".csv" class="block w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-lg file:border-0
                        file:text-sm file:font-medium
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100">
                        
                    <div class="flex justify-between items-center">
                        <div class="flex space-x-4">
                            <button id="processBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>Process Data</button>
                            <button id="downloadBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>Download Results</button>
                            <button id="resetBtn" class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 font-medium">Reset</button>
                        </div>
                        <button id="removalBtn" onclick="generateRemovalFile()" class="px-4 py-2 bg-gray-200 text-black rounded-lg hover:bg-gray-300 font-medium disabled:bg-gray-300 disabled:cursor-not-allowed">
                            <span class="flex items-center">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                                Removal Request
                            </span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="processingCanvas"></canvas>
            </div>

            <!-- Add the new completion message div -->
            <div id="completionMessage" class="hidden transition-opacity duration-300 bg-green-50 border-l-4 border-green-500 p-4 mb-8 rounded-lg">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-green-700">
                            Processing complete. All personal identifiers have been removed. Scroll up to see a preview of the processed data.
                        </p>
                    </div>
                </div>
            </div>

            <!-- SharePoint Upload Guide Section -->
            <div id="uploadGuide" class="upload-guide mt-8">
                <div class="border-t pt-8">
                    <h3 class="text-xl font-bold mb-4">Next Step: Secure File Storage</h3>
                    
                    <div class="bg-blue-50 rounded-lg p-6 mb-6">
                        <div class="flex items-start space-x-3">
                            <svg class="w-6 h-6 text-blue-500 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <p class="text-sm text-blue-800">
                                For security, please save your processed file to our dedicated SharePoint folder. It will be automatically moved to a secure location for insight processing, by only the authorised tool.
                                <br>
                                <br>
                                To further safeguard your data and reduce the risk of unintended access or misuse, we strongly recommend deleting the file from your local downloads after upload.
                            </p>
                        </div>
                    </div>

                    <div class="space-y-6">
                        <div class="step-animation flex items-center space-x-4 bg-white rounded-lg p-4 shadow-sm border border-gray-100">
                            <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center">
                                <span class="text-blue-600 font-semibold">1</span>
                            </div>
                            <div class="flex-grow">
                                <h4 class="font-semibold">Download Processed File</h4>
                                <p class="text-sm text-gray-600 mb-2">Save your anonymized contact data</p>
                                <button onclick="CanvasProcessor.downloadProcessedData()" 
                                        class="inline-flex items-center px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 text-sm transition-colors duration-150">
                                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                    </svg>
                                    Download Results
                                </button>
                            </div>
                        </div>

                        <div class="step-animation flex items-center space-x-4 bg-white rounded-lg p-4 shadow-sm border border-gray-100">
                            <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center">
                                <span class="text-blue-600 font-semibold">2</span>
                            </div>
                            <div class="flex-grow">
                                <h4 class="font-semibold">Open SharePoint Location</h4>
                                <p class="text-sm text-gray-600 mb-2">Access our secure file storage area</p>
                                <button onclick="scrollToSharePointLocation()" 
                                        class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm transition-colors duration-150">
                                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                                    </svg>
                                    Open SharePoint Folder
                                </button>
                            </div>
                        </div>

                        <div class="step-animation flex items-center space-x-4 bg-white rounded-lg p-4 shadow-sm border border-gray-100">
                            <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center">
                                <span class="text-blue-600 font-semibold">3</span>
                            </div>
                            <div>
                                <h4 class="font-semibold">Upload Your File</h4>
                                <p class="text-sm text-gray-600">Drag and drop or use the upload button in SharePoint</p>
                            </div>
                        </div>

                        <div class="step-animation flex items-center space-x-4 bg-white rounded-lg p-4 shadow-sm border border-gray-100">
                            <div class="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center">
                                <span class="text-blue-600 font-semibold">4</span>
                            </div>
                            <div>
                                <h4 class="font-semibold">That's it!</h4>
                                <p class="text-sm text-gray-600">The growth team will be in touch directly with you about network insights and follow-ups.</p>
                            </div>
                        </div>

                        <div class="text-sm text-gray-500 mt-4">
                            Need help? Contact the Growth team for assistance.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Data Removal Section at the bottom -->
            <div class="mt-8 pt-8 border-t border-gray-200">
                <div class="bg-gray-50 rounded-lg p-6">
                    <h4 class="text-lg font-semibold mb-3">Data Removal Request</h4>
                    <p class="text-sm text-gray-600 mb-4">
                        If at any point in the future you want your data removed, simply upload the file below to the same 
                        <a href="https://interpublic.sharepoint.com/:f:/r/sites/MBContactInsights/Shared%20Documents/1.Contact%20Drop%20Box?csf=1&web=1&e=77M1Fn" 
                           target="_blank" 
                           class="text-blue-600 hover:text-blue-800 underline">SharePoint folder</a> 
                        - this will signal our system to purge all data associated with your uploads.
                    </p>
                    <!-- Ensure the button is left-aligned -->
                    <div class="flex justify-start">
                        <button onclick="generateRemovalFile()" 
                                class="inline-flex items-center px-4 py-2 bg-gray-200 text-black rounded-md hover:bg-gray-300 text-sm transition-colors duration-150">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                            Removal Request
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    //pass in the param into name    
    document.addEventListener('DOMContentLoaded', () => {
        const params = new URLSearchParams(window.location.search);
        const id = params.get('ID');
        if (id) {
            document.getElementById('uploaderName').value = id;
        }
    });
    // Constants and Configuration
    const BREAKPOINTS = {
        MOBILE: 768,
        TABLET: 1024,
        DESKTOP: 1200
    };

    const ANIMATION = {
        DURATION: 300,
        EASING: t => t * (2 - t),
        MIN_FRAME_TIME: 1000/60
    };

    const EventTypes = {
        DATA_LOADED: 'dataLoaded',
        PROCESSING_START: 'processingStart',
        PROCESSING_PROGRESS: 'processingProgress',
        PROCESSING_COMPLETE: 'processingComplete',
        ERROR: 'error',
        STATE_CHANGE: 'stateChange'
    };

    // Add these two lines here
    const ENCODE_NAMES = true; // Toggle switch for name encoding
    const SHIFT_KEY = 5; // Simple shift value

    // Add encoding function here
    function encodeString(str) {
        if (!ENCODE_NAMES) return str;
        
        // Get first initial
        const firstInitial = str.charAt(0);
        
        // Encode rest of string
        const encoded = str.split('')
            .map(char => {
                // Only encode letters and numbers
                if (char.match(/[a-zA-Z0-9]/)) {
                    const code = char.charCodeAt(0);
                    // Shift the character by SHIFT_KEY positions
                    if (code >= 65 && code <= 90) // Uppercase
                        return String.fromCharCode(((code - 65 + SHIFT_KEY) % 26) + 65);
                    if (code >= 97 && code <= 122) // Lowercase
                        return String.fromCharCode(((code - 97 + SHIFT_KEY) % 26) + 97);
                    if (code >= 48 && code <= 57) // Numbers
                        return String.fromCharCode(((code - 48 + SHIFT_KEY) % 10) + 48);
                }
                return char; // Leave other characters unchanged
            })
            .join('');
        
        return `U${firstInitial}_${encoded}`;
    }
    // Event System
    const EventSystem = {
        events: {},
        validEvents: new Set(Object.values(EventTypes)),
        debug: false,

        initEvents() {
            this.events = {};
        },

        setDebug(enabled) {
            this.debug = enabled;
        },

        on(eventName, callback) {
            if (!this.validEvents.has(eventName)) {
                console.warn(`Warning: Subscribing to undefined event '${eventName}'`);
            }
            if (!this.events[eventName]) {
                this.events[eventName] = [];
            }
            this.events[eventName].push(callback);
        },

        emit(eventName, data) {
            if (!this.validEvents.has(eventName)) {
                console.warn(`Warning: Emitting undefined event '${eventName}'`);
            }
            if (this.debug) {
                console.log(`Event emitted: ${eventName}`, data);
            }
            if (this.events[eventName]) {
                this.events[eventName].forEach(callback => callback(data));
            }
        }
    };

    // Base Component
    const BaseComponent = {
        processor: null,
        _textCache: new Map(),
        
        init(processor) {
            this.processor = processor;
        },
        
        getResponsiveConfig() {
            const width = window.innerWidth;
            if (width < BREAKPOINTS.MOBILE) {
                return {
                    padding: 15,
                    fontSize: 12,
                    headerSize: 14,
                    rowHeight: 20,
                    maxRows: 3
                };
            } else if (width < BREAKPOINTS.TABLET) {
                return {
                    padding: 20,
                    fontSize: 13,
                    headerSize: 15,
                    rowHeight: 22,
                    maxRows: 4
                };
            }
            return {
                padding: 30,
                fontSize: 14,
                headerSize: 16,
                rowHeight: 24,
                maxRows: 5
            };
        },
        
        getFontForDisplay(type = 'normal') {
            const config = this.getResponsiveConfig();
            const size = type === 'header' ? config.headerSize : config.fontSize;
            return `${type === 'header' ? 'bold ' : ''}${size}px system-ui`;
        },
        
        measureText(ctx, text, font) {
            const key = `${text}-${font}`;
            if (!this._textCache.has(key)) {
                ctx.font = font;
                this._textCache.set(key, ctx.measureText(text));
            }
            return this._textCache.get(key);
        },
        
        clearTextCache() {
            this._textCache.clear();
        },
        
        truncateText(ctx, text, maxWidth) {
            if (this.measureText(ctx, text, ctx.font).width <= maxWidth) return text;
            let truncated = text;
            while (truncated.length > 3 && 
                   this.measureText(ctx, truncated + '...', ctx.font).width > maxWidth) {
                truncated = truncated.slice(0, -1);
            }
            return truncated + '...';
        },
        
        drawScrollIndicator(ctx, bounds, { hasMore, direction = 'down' }) {
            if (!hasMore) return;
            
            const { x, y, width } = bounds;
            const size = 8;
            
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            
            if (direction === 'down') {
                ctx.moveTo(x + width/2 - size, y);
                ctx.lineTo(x + width/2 + size, y);
                ctx.lineTo(x + width/2, y + size);
            } else {
                ctx.moveTo(x + width/2 - size, y + size);
                ctx.lineTo(x + width/2 + size, y + size);
                ctx.lineTo(x + width/2, y);
            }
            
            ctx.closePath();
            ctx.fill();
        },
        
        animateValue(start, end, progress) {
            return start + (end - start) * ANIMATION.EASING(progress);
        }
    };

    // Status Component
    const StatusComponent = Object.assign(Object.create(BaseComponent), {
        animation: {
            progress: null,
            startTime: 0,
            startValue: 0,
            endValue: 0
        },
        
        render(ctx, bounds) {
            const { x, y, width } = bounds;
            const config = this.getResponsiveConfig();
            const height = config.rowHeight * 1.5;
            const { status } = this.processor.state;
            
            // Background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(x, y, width, height);
            
            // Status text
            ctx.font = this.getFontForDisplay();
            ctx.fillStyle = this.getStatusColor();
            ctx.textAlign = 'left';
            ctx.fillText(this.getStatusText(), x + config.padding, y + height/2 + 5);
            
            // Animated progress bar
            if (status === 'PROCESSING') {
                this.updateProgressAnimation();
                this.drawProgressBar(ctx, {
                    x: x + config.padding,
                    y: y + height - 8,
                    width: width - (config.padding * 2),
                    height: 4
                });
            }
            
            return height;
        },
        
        getStatusColor() {
            const { status } = this.processor.state;
            switch (status) {
                case 'ERROR': return '#dc3545';
                case 'COMPLETE': return '#28a745';
                case 'PROCESSING': return '#0066cc';
                default: return '#333333';
            }
        },
        
        getStatusText() {
            const { status, error } = this.processor.state;
            switch (status) {
                case 'ERROR': 
                    return `Error: ${error || 'Unknown error'}`;
                case 'PROCESSING': 
                    return `Processing... ${Math.round(this.animation.progress * 100)}%`;
                case 'COMPLETE': {
                    const stats = this.processor.removedFieldsStats;
                    if (!stats) return `Processing complete - ${this.processor.processedData.length} entries processed`;
                    
                    const removedStats = Object.entries(stats)
                        .map(([field, count]) => `${field}: ${count}`)
                        .join(', ');
                    return `Processing complete - ${this.processor.processedData.length} entries processed (Removed: ${removedStats})`;
                }
                case 'IDLE': 
                    return 'Ready to process data';
                default: 
                    return status;
            }
        },
        
        updateProgressAnimation() {
            const { progress } = this.processor.state;
            
            // Set initial progress to 33% if we're just starting
            if (progress === 0) {
                this.animation.progress = 0.33;
                return;
            }
            
            const now = performance.now();
            if (progress !== this.animation.endValue) {
                this.animation.startTime = now;
                this.animation.startValue = this.animation.progress || 0.33; // Start from 33% if no progress
                this.animation.endValue = progress;
            }
            
            const elapsed = now - this.animation.startTime;
            const duration = ANIMATION.DURATION;
            
            if (elapsed >= duration) {
                this.animation.progress = progress;
            } else {
                this.animation.progress = this.animateValue(
                    this.animation.startValue,
                    this.animation.endValue,
                    elapsed / duration
                );
            }
        },
        
        drawProgressBar(ctx, bounds) {
            const { x, y, width, height } = bounds;
            
            // Background
            ctx.fillStyle = '#e9ecef';
            ctx.fillRect(x, y, width, height);
            
            // Progress
            const progress = this.animation.progress || 0;
            if (progress > 0) {
                ctx.fillStyle = '#0066cc';
                ctx.fillRect(x, y, width * progress, height);
            }
        }
    });

    // Preview Component
    const PreviewComponent = Object.assign(Object.create(BaseComponent), {
        scroll: {
            offset: 0,
            velocity: 0,
            lastTime: 0
        },
        interactiveAreas: [],
        hoveredArea: null,
        
        render(ctx, bounds, data) {
            const config = this.getResponsiveConfig();
            const { x, y, width, height } = bounds;
            
            // Start with proper padding
            let currentY = y + config.padding;
            
            // Section title
            ctx.font = this.getFontForDisplay('header');
            ctx.fillStyle = this.processor.colors.primary;
            ctx.fillText(
                this.processor.state.status === 'COMPLETE' ? 'Processing Results' : 'Data Preview',
                x + config.padding,
                currentY
            );
            currentY += config.rowHeight * 1.5;
            
            // Headers
            const headers = data.headers;
            const colWidth = (width - config.padding * 2) / headers.length;
            
            ctx.font = this.getFontForDisplay('header');
            headers.forEach((header, i) => {
                // Skip rendering the Encrypted Token header during preview
                if (header === 'Encrypted Token' && this.processor.state.status === 'PREVIEW') {
                    return;
                }
                const truncated = this.truncateText(ctx, header, colWidth - 10);
                ctx.fillText(
                    truncated,
                    x + config.padding + (i * colWidth),
                    currentY
                );
            });
            
            // Add extra spacing after headers before starting rows
            currentY += config.rowHeight * 1.2;
            
            // Draw rows
            ctx.font = this.getFontForDisplay();
            const visibleRows = data.rows;
            
            visibleRows.forEach((row, i) => {
                const rowY = currentY + (i * config.rowHeight);
                
                // Row background
                if (i % 2 === 0) {
                    ctx.fillStyle = 'rgba(0,0,0,0.02)';
                    ctx.fillRect(
                        x + config.padding,
                        rowY - config.rowHeight + 5,
                        width - config.padding * 2,
                        config.rowHeight
                    );
                }
                
                // Clear previous interactive areas
                this.interactiveAreas = [];

                // Row data
                headers.forEach((header, j) => {
                    const value = row[header] || '';
                    const isProcessed = this.processor.state.status === 'COMPLETE';
                    const isRemovedField = isProcessed && value === '<Removed>';
                    const isIdField = header === 'Encrypted Token';
                    
                    ctx.fillStyle = isRemovedField ? '#9CA3AF' : this.processor.colors.text;
                    
                    let displayValue = value;
                    if (isIdField && value) {
                        displayValue = `ðŸ”’ (${value.substring(0, 5)}...)`;
                        
                        // Store the area for this ID field
                        const cellX = x + config.padding + (j * colWidth);
                        const cellWidth = this.measureText(ctx, displayValue, ctx.font).width;
                        
                        this.interactiveAreas.push({
                            x: cellX,
                            y: rowY - config.rowHeight + 5,
                            width: cellWidth,
                            height: config.rowHeight,
                            fullId: value,
                            displayValue
                        });

                        // If this area is being hovered, show the full ID
                        if (this.hoveredArea && 
                            this.hoveredArea.x === cellX && 
                            this.hoveredArea.y === rowY - config.rowHeight + 5) {
                            displayValue = `ðŸ”’ ${value}`;
                            ctx.fillStyle = '#0066cc'; // Highlight color
                        }
                    }
                    
                    const truncated = this.truncateText(
                        ctx,
                        displayValue.toString(),
                        colWidth - 10
                    );
                    ctx.fillText(
                        truncated,
                        x + config.padding + (j * colWidth),
                        rowY
                    );
                });
            });

            // Only show scroll indicators if we actually have more rows than we can display
            const visibleRowCount = config.maxRows;
            const actualRowCount = data.rows.length;
            if (actualRowCount > visibleRowCount) {
                this.drawScrollIndicators(ctx, {
                    x,
                    y: y + height - config.padding,
                    width,
                    startIndex: this.scroll.offset,  // Use actual scroll offset
                    totalRows: actualRowCount,
                    visibleRows: visibleRowCount
                });
            }

            return height;
        },

        drawScrollIndicators(ctx, { x, y, width, startIndex, totalRows, visibleRows }) {
            // Draw up indicator if we're not at the top
            if (startIndex > 0) {
                this.drawScrollIndicator(ctx, {
                    x,
                    y: y - 20,  // Move up a bit
                    width
                }, { 
                    hasMore: true, 
                    direction: 'up' 
                });
            }

            // Draw down indicator if we have more rows below
            if (startIndex + visibleRows < totalRows) {
                this.drawScrollIndicator(ctx, {
                    x,
                    y,
                    width
                }, { 
                    hasMore: true, 
                    direction: 'down' 
                });
            }
        },

        handleResize() {
            this.scroll.offset = 0;
            this.scroll.velocity = 0;
            this.clearTextCache();
        },

        handleMouseMove(event) {
            const rect = this.processor.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if mouse is over any interactive area
            const hoveredArea = this.interactiveAreas.find(area => 
                x >= area.x && 
                x <= area.x + area.width && 
                y >= area.y && 
                y <= area.y + area.height
            );

            if (hoveredArea !== this.hoveredArea) {
                this.hoveredArea = hoveredArea;
                this.processor.canvas.style.cursor = hoveredArea ? 'pointer' : 'default';
                this.processor.drawProcessingResults();
            }
        },

        handleClick(event) {
            const rect = this.processor.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Check if click is on any interactive area
            const clickedArea = this.interactiveAreas.find(area => 
                x >= area.x && 
                x <= area.x + area.width && 
                y >= area.y && 
                y <= area.y + area.height
            );

            if (clickedArea) {
                // Copy to clipboard
                navigator.clipboard.writeText(clickedArea.fullId)
                    .then(() => {
                        // Show a temporary tooltip or message
                        alert('ID copied to clipboard!');
                    })
                    .catch(err => console.error('Failed to copy:', err));
            }
        }
    });

    // Canvas Processor
    const CanvasProcessor = {
        canvas: null,
        ctx: null,
        data: null,
        processedData: null,
        skippedData: null,
        animation: null,
        scale: window.devicePixelRatio || 1,
        
        colors: {
            background: '#ffffff',
            text: '#333333',
            primary: '#0066cc',
            success: '#28a745',
            warning: '#ffc107',
            error: '#dc3545',
            grid: '#f0f0f0',
            highlight: '#e3f2fd'
        },

        components: {},
        
        setupCanvas: function() {
            const rect = this.canvas.getBoundingClientRect();
            this.canvas.width = rect.width * this.scale;
            this.canvas.height = rect.height * this.scale;
            this.ctx.scale(this.scale, this.scale);
            this.ctx.font = '14px system-ui';
        },
        
        init: function() {
            this.initEvents();
            this.setDebug(true);
            
            this.canvas = document.getElementById('processingCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.setupCanvas();
            
            // Initialize components
            this.components = {
                status: Object.create(StatusComponent),
                preview: Object.create(PreviewComponent)
            };
            
            Object.values(this.components).forEach(component => {
                component.init(this);
            });
            
            this.setupEventHandlers();
            this.bindEvents();
            
            this.state = {
                status: 'IDLE',
                progress: 0,
                error: null
            };
            
            this.drawInitialState();
        },
        
        destroy() {
            if (this._boundHandlers) {
                window.removeEventListener('resize', this._boundHandlers.resize);
                this.canvas.removeEventListener('wheel', this._boundHandlers.scroll);
                this.canvas.removeEventListener('mousemove', this._boundHandlers.mouseMove);
                this.canvas.removeEventListener('click', this._boundHandlers.click);
            }

            Object.values(this.components).forEach(component => {
                if (component.clearTextCache) {
                    component.clearTextCache();
                }
            });
        },
        
        handleResize() {
            this.setupCanvas();
            Object.values(this.components).forEach(component => {
                if (component.handleResize) {
                    component.handleResize();
                }
            });
            this.drawProcessingResults();
        },
        
        setupEventHandlers() {
            this.on(EventTypes.DATA_LOADED, (data) => {
                console.log('Data loaded:', data?.rows?.length || 0, 'rows');
                this.setState({ status: 'PREVIEW', data });
            });

            this.on(EventTypes.PROCESSING_START, () => {
                console.log('Processing started');
                this.setState({ status: 'PROCESSING', progress: 0 });
            });

            this.on(EventTypes.PROCESSING_PROGRESS, (progress) => {
                console.log('Processing progress:', progress);
                this.setState({ progress });
            });

            this.on(EventTypes.PROCESSING_COMPLETE, (result) => {
                console.log('Processing complete:', result);
                this.setState({ 
                    status: 'COMPLETE',
                    progress: 1,
                    processedData: result.processed,
                    skippedData: result.skipped
                });
                
                document.getElementById('downloadBtn').disabled = !result.processed?.length;
                
                // Show completion message
                const completionMessage = document.getElementById('completionMessage');
                completionMessage.classList.remove('hidden');
                completionMessage.classList.add('opacity-100');
                
                // Show the upload guide with animation
                const uploadGuide = document.getElementById('uploadGuide');
                uploadGuide.style.display = 'block';
                // Trigger reflow
                uploadGuide.offsetHeight;
                uploadGuide.classList.add('visible');

                // Modified scroll behavior with offset
                setTimeout(() => {
                    const completionMessage = document.getElementById('completionMessage');
                    if (completionMessage) {
                        const offset = 70; // Adjust this value to control the scroll position
                        const elementPosition = completionMessage.getBoundingClientRect().top;
                        const offsetPosition = elementPosition + window.pageYOffset - offset;
                        
                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });
                    }
                }, 300);
            });

            this.on(EventTypes.ERROR, (error) => {
                console.error('Error:', error);
                this.setState({ 
                    status: 'ERROR',
                    error: error.message || error
                });
            });
        }, // <-- Added missing comma here
                
        bindEvents() {
            // First, remove any existing event listeners to prevent duplicates
            const fileInput = document.getElementById('fileInput');
            const processBtn = document.getElementById('processBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const resetBtn = document.getElementById('resetBtn');
            const removalBtn = document.getElementById('removalBtn');

            // Clean up existing bound functions if they exist
            if (this._boundHandlers) {
                if (fileInput) fileInput.removeEventListener('change', this._boundHandlers.fileSelect);
                if (processBtn) processBtn.removeEventListener('click', this._boundHandlers.process);
                if (downloadBtn) downloadBtn.removeEventListener('click', this._boundHandlers.download);
                if (resetBtn) resetBtn.removeEventListener('click', this._boundHandlers.reset);
                window.removeEventListener('resize', this._boundHandlers.resize);
                this.canvas.removeEventListener('wheel', this._boundHandlers.scroll);
                this.canvas.removeEventListener('mousemove', this._boundHandlers.mouseMove);
                this.canvas.removeEventListener('click', this._boundHandlers.click);
            }

            // Create new bound handlers
            this._boundHandlers = {
                fileSelect: this.handleFileSelect.bind(this),
                process: this.processData.bind(this),
                download: this.downloadProcessedData.bind(this),
                reset: this.reset.bind(this),
                resize: this.handleResize.bind(this),
                scroll: this.handleScroll.bind(this),
                mouseMove: this.components.preview?.handleMouseMove.bind(this.components.preview),
                click: this.components.preview?.handleClick.bind(this.components.preview)
            };

            // Add new event listeners
            if (fileInput) {
                fileInput.addEventListener('change', this._boundHandlers.fileSelect);
            }
            if (processBtn) {
                processBtn.addEventListener('click', this._boundHandlers.process);
            }
            if (downloadBtn) {
                downloadBtn.addEventListener('click', this._boundHandlers.download);
            }
            if (resetBtn) {
                resetBtn.addEventListener('click', this._boundHandlers.reset);
            }

            window.addEventListener('resize', this._boundHandlers.resize);
            this.canvas.addEventListener('wheel', this._boundHandlers.scroll);

            // Only add these listeners if the preview component is initialized
            if (this.components.preview) {
                this.canvas.addEventListener('mousemove', this._boundHandlers.mouseMove);
                this.canvas.addEventListener('click', this._boundHandlers.click);
            }
        },
        
        setState(newState) {
            this.state = { ...this.state, ...newState };
            this.emit(EventTypes.STATE_CHANGE, this.state);
            requestAnimationFrame(() => this.drawProcessingResults());
        },
        
        handleScroll(event) {
            event.preventDefault();
            
            if (!this.data?.rows.length) return;
            
            const previewComponent = this.components.preview;
            previewComponent.scroll.velocity += event.deltaY * 0.1;
            
            this.drawProcessingResults();
        },
        
        drawInitialState() {
            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(0, 0, this.canvas.width / this.scale, this.canvas.height / this.scale);
            
            this.ctx.fillStyle = this.colors.text;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                'Select a CSV file to begin processing',
                (this.canvas.width / this.scale) / 2,
                (this.canvas.height / this.scale) / 2
            );
        },
        
        drawProcessingResults() {
            const width = this.canvas.width / this.scale;
            const height = this.canvas.height / this.scale;
            const config = this.components.preview.getResponsiveConfig();

            // Clear canvas
            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(0, 0, width, height);

            let currentY = config.padding;

            // Status section (always shown)
            currentY += this.components.status.render(this.ctx, {
                x: 0,
                y: currentY,
                width: width
            });

            // If processing, don't show preview
            if (this.state.status === 'PROCESSING') {
                requestAnimationFrame(() => this.drawProcessingResults());
                return;
            }

            // Add spacing between sections
            currentY += config.padding * 1.5;

            // Data preview or results
            if (this.data) {
                const remainingHeight = height - currentY - config.padding;
                
                this.components.preview.render(this.ctx, {
                    x: 0,
                    y: currentY,
                    width: width,
                    height: remainingHeight
                }, this.data);
            }
        },
        
        async handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = this.parseCSV(text);
                this.data = data;
                document.getElementById('processBtn').disabled = false;
                this.emit(EventTypes.DATA_LOADED, data);

                // Increase offset to scroll further down
                setTimeout(() => {
                    const processBtn = document.getElementById('processBtn');
                    const offset = 245;
                    const targetPosition = processBtn.getBoundingClientRect().top + window.pageYOffset - offset;
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }, 100);
            } catch (err) {
                this.emit(EventTypes.ERROR, err);
            }
        },
        
        parseCSV(text) {
            const rows = text.split(/\r?\n/);
            const headerRow = rows.find(row => 
                row.includes('Company') && 
                row.includes('Position') &&
                row.includes('Connected On')
            );
            
            if (!headerRow) {
                throw new Error('Invalid CSV format: Missing required headers');
            }

            const headers = [...headerRow.split(',').map(h => h.trim()), 'Encrypted Token'];
            const dataStartIndex = rows.indexOf(headerRow) + 1;
            
            return {
                headers,
                rows: rows.slice(dataStartIndex)
                    .filter(row => row.trim())
                    .map(row => {
                        const values = this.parseCSVRow(row);
                        return headers.reduce((acc, header, i) => {
                            acc[header] = values[i] || '';
                            return acc;
                        }, {});
                    })
            };
        },

        parseCSVRow(row) {
            const values = [];
            let insideQuotes = false;
            let currentValue = '';
            
            for (let char of row) {
                if (char === '"') {
                    insideQuotes = !insideQuotes;
                } else if (char === ',' && !insideQuotes) {
                    values.push(currentValue.trim());
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }
            values.push(currentValue.trim());
            
            return values;
        },

        processData: function() {
            // Prevent multiple simultaneous processing
            if (this.state.status === 'PROCESSING') {
                console.log('Already processing, ignoring request');
                return;
            }

            try {
                const enableTracking = document.getElementById('enableTracking').checked;
                const uploaderName = document.getElementById('uploaderName').value;
                const nameWarning = document.getElementById('nameWarning');
                // Add this line after getting uploaderName
                const encodedName = encodeString(uploaderName);
                if (!uploaderName) {
                    nameWarning.style.display = 'inline';
                    return;
                }
                nameWarning.style.display = 'none';

                this.emit(EventTypes.PROCESSING_START);
                
                // Store original data structure before processing
                this.originalData = {
                    headers: [...this.data.headers],
                    rows: [...this.data.rows]
                };
                
                // Find and store most recent date BEFORE processing
                try {
                    const mostRecentDate = this.data.rows
                        .map(row => row['Connected On'])
                        .filter(date => {
                            if (!date) return false;
                            try {
                                const testDate = new Date(date);
                                return testDate instanceof Date && !isNaN(testDate);
                            } catch {
                                return false;
                            }
                        })
                        .sort((a, b) => new Date(b) - new Date(a))[0];

                    // Always set mostRecentConnectionDate, regardless of tracking
                    this.mostRecentConnectionDate = mostRecentDate ? 
                        new Date(mostRecentDate)
                            .toISOString()
                            .split('T')[0]
                            .replace(/-/g, '') 
                        : 'NoDate';
                        
                    console.log('Most recent date:', this.mostRecentConnectionDate); // Debug log
                } catch (dateErr) {
                    console.warn('Date parsing error:', dateErr);
                    this.mostRecentConnectionDate = 'NoDate';
                }

                const processed = [];
                const skipped = [];
                const seenRoleIds = new Set();
                const removedFields = ['First Name', 'Last Name', 'URL', 'Email Address', 'Connected On'];
                const removedFieldsStats = {}; // Add stats tracking
                
                // Create a copy of the data rows
                const rows = [...this.data.rows];
                const totalRows = rows.length;
                const batchSize = 50;
                
                const processRowsWithDelay = async () => {
                    for (let i = 0; i < totalRows; i += batchSize) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                        
                        const end = Math.min(i + batchSize, totalRows);
                        for (let j = i; j < end; j++) {
                            const row = rows[j];
                            try {
                                const company = (row['Company'] || '').trim();
                                const position = (row['Position'] || '').trim();
                                const url = row['URL'] || '';

                                // Only skip if BOTH company AND position are missing
                                if (!company || !position) {
                                    skipped.push({
                                        row: j + 1,
                                        reason: 'Missing required company or position',
                                        data: row
                                    });
                                    continue;
                                }

                                const ids = this.generateIds(company, position, url, enableTracking);
                                
                                // Track removed fields for stats
                                removedFields.forEach(field => {
                                    if (row[field]) {
                                        removedFieldsStats[field] = (removedFieldsStats[field] || 0) + 1;
                                    }
                                });

                                const processedRow = {
                                    ...row,
                                    'Encrypted Token': ids.mainToken,
                                    company: company,
                                    position: position,
                                    mainToken: ids.mainToken,
                                    prefToken: ids.prefToken,
                                    uploader: encodedName,
                                    uploadDate: new Date().toISOString()
                                };

                                // Mark removed fields
                                removedFields.forEach(field => {
                                    if (row[field]) {
                                        processedRow[field] = '<Removed>';
                                    }
                                });

                                processed.push(processedRow);
                            } catch (err) {
                                skipped.push({
                                    row: j + 1,
                                    reason: err.message,
                                    data: row
                                });
                            }
                        }
                        
                        this.emit(EventTypes.PROCESSING_PROGRESS, end / totalRows);
                    }

                    this.processedData = processed;
                    this.skippedData = skipped;
                    
                    // Keep original headers but update the rows with processed data
                    this.data = {
                        headers: this.originalData.headers,
                        rows: processed
                    };
                    
                    this.removedFieldsStats = removedFieldsStats; // Store stats
                    this.emit(EventTypes.PROCESSING_COMPLETE, { processed, skipped });
                };

                processRowsWithDelay().catch(err => {
                    this.emit(EventTypes.ERROR, err);
                });
                
            } catch (err) {
                this.emit(EventTypes.ERROR, err);
            }
        },

        downloadProcessedData() {
            if (!this.processedData || !Array.isArray(this.processedData)) {
                console.error('No processed data available');
                return;
            }

            if (this.processedData.length === 0) {
                console.error('No records to download');
                return;
            }
            
            try {
                // Get submitter name and encode it
                const uploaderName = document.getElementById('uploaderName').value;
                const encodedName = encodeString(uploaderName);
                
                // Use the stored most recent date, with better fallback
                const formattedMostRecent = this.mostRecentConnectionDate || 'NoDate';
                
                // Format current date (pull date)
                const pullDate = new Date()
                    .toISOString()
                    .split('T')[0]
                    .replace(/-/g, '');
                
                // Create filename with encoded name - add console.log to debug
                console.log('Creating filename with:', {encodedName, formattedMostRecent, pullDate});
                const filename = `${encodedName}_MR_${formattedMostRecent}_PD_${pullDate}.csv`;
                
                // Define the fields we want to keep in the output
                const desiredFields = [
                    'company',
                    'position',
                    'mainToken',
                    'prefToken',
                    'uploader',
                    'uploadDate'
                ];
                
                // Filter the data to only include desired fields
                const sanitizedData = this.processedData.map(row => {
                    return desiredFields.reduce((obj, field) => {
                        if (field === 'uploader') {
                            obj[field] = encodedName;
                        } else if (field === 'mainToken') {
                            obj[field] = row.mainToken || '';
                        } else if (field === 'prefToken') {
                            obj[field] = row.prefToken || '';
                        } else {
                            obj[field] = row[field] || '';
                        }
                        return obj;
                    }, {});
                });

                const headers = desiredFields;
                const csv = [
                    headers.join(','),
                    ...sanitizedData.map(row => 
                        headers.map(header => {
                            const value = row[header] || '';
                            // Handle values that need quotes
                            return value.includes(',') || value.includes('"') || value.includes('\n') 
                                ? `"${value.replace(/"/g, '""')}"` 
                                : value;
                        }).join(',')
                    )
                ].join('\n');
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                console.log('Download complete:', sanitizedData.length, 'records');
                
            } catch (err) {
                console.error('Download error:', err);
                this.emit(EventTypes.ERROR, 'Failed to download data: ' + err.message);
            }
        },

        generateIds: function(company, position, url, enableTracking) {
            if (!company && !position) {
                throw new Error('Both company and position cannot be empty');
            }
            
            let mainToken, prefToken;

            if (!url || url === '') {
                // No URL = Minimal Token (M)
                // Same person/role should generate same token regardless of uploader
                mainToken = 'M_' + CryptoJS.SHA256(company + position).toString().substring(0, 16);
                prefToken = '';
            } else if (enableTracking) {
                // URL exists and tracking enabled = Solo Token (S) + Tracked Token (T)
                mainToken = 'S_' + CryptoJS.SHA256(company + position + url).toString().substring(0, 16);
                prefToken = 'T_' + CryptoJS.SHA256(url).toString().substring(0, 16);
            } else {
                // URL exists but tracking disabled = Solo Token (S) only
                mainToken = 'S_' + CryptoJS.SHA256(company + position + url).toString().substring(0, 16);
                prefToken = '';
            }

            console.log('Token generation:', { 
                hasUrl: !!url,
                enableTracking,
                mainToken,
                prefToken
            });

            return { mainToken, prefToken };
        },
        
        reset() {
            this.data = null;
            this.processedData = null;
            this.state = {
                status: 'IDLE',
                progress: 0,
                error: null
            };
            document.getElementById('fileInput').value = '';
            document.getElementById('processBtn').disabled = true;
            document.getElementById('downloadBtn').disabled = true;
            
            // Add SharePoint guide reset handling
            const uploadGuide = document.getElementById('uploadGuide');
            uploadGuide.classList.remove('visible');
            setTimeout(() => {
                uploadGuide.style.display = 'none';
            }, 300);
            
            // Hide completion message
            const completionMessage = document.getElementById('completionMessage');
            completionMessage.classList.add('hidden');
            completionMessage.classList.remove('opacity-100');
            
            this.drawInitialState();
        }
    };

    // Initialize the event system
    Object.assign(CanvasProcessor, EventSystem);

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        CanvasProcessor.init();
        
        // Add cleanup on page unload
        window.addEventListener('unload', () => {
            CanvasProcessor.destroy();
        });
    });

    // Add this function near your other JavaScript functions
    function generateRemovalFile() {
        const uploaderName = document.getElementById('uploaderName').value;
        if (!uploaderName) {
            alert('Please enter your name first');
            return;
        }
        const encodedName = encodeString(uploaderName);

        // Create the removal request content
        const content = [
            'removal_request,timestamp',
            `${encodedName},${new Date().toISOString()}`
        ].join('\n');

        // Generate filename with date
        const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
        const filename = `${encodedName}_${date}_Remove.csv`;

        // Create and download the file
        const blob = new Blob([content], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Show confirmation message
        alert('Removal request file generated. Please upload this file to the same SharePoint location linked at the end of the page to initiate data removal.');
    }

    document.addEventListener('DOMContentLoaded', () => {
        const uploaderNameInput = document.getElementById('uploaderName');
        const removalBtn = document.getElementById('removalBtn');

        uploaderNameInput.addEventListener('input', () => {
            removalBtn.disabled = !uploaderNameInput.value.trim();
        });

        // If there's an initial value (from URL params)
        if (uploaderNameInput.value.trim()) {
            removalBtn.disabled = false;
        }
    });

    function scrollToSharePointLocation() {
        window.open('https://interpublic.sharepoint.com/:f:/r/sites/MBContactInsights/Shared%20Documents/1.Contact%20Drop%20Box?csf=1&web=1&e=77M1Fn', '_blank');
        
        // Scroll to the "Open SharePoint Location" section
        const sharePointSection = document.querySelector('.step-animation:nth-child(2)');
        if (sharePointSection) {
            const offset = 70; // Adjust this value to control the scroll position
            const elementPosition = sharePointSection.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - offset;
            
            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });
        }
    }
    </script>
    <!-- Help Button -->
    <a href="guide.html" target="_blank" class="fixed bottom-5 right-5 w-12 h-12 bg-blue-600 rounded-full flex items-center justify-center text-white text-2xl font-bold shadow-lg hover:bg-blue-700 transition-colors duration-200 z-50 group">
        ?
        <span class="absolute right-16 bottom-0 bg-white px-3 py-2 rounded text-sm text-gray-700 shadow-md opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 whitespace-nowrap">
            Stuck? Click for step-by-step guide
        </span>
    </a>
</body>
</html>
